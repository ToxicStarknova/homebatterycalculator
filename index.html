import React, { useState, useEffect, useMemo } from 'react';
import {
  ResponsiveContainer,
  ComposedChart,
  Line,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ReferenceLine,
} from 'recharts';

// --- Configuration Constants ---
// Feel free to adjust these to model different scenarios
const BATTERY_CONFIG = {
  capacityKWh: 13.5,       // Total capacity of the battery
  maxChargeRateKw: 5.0,    // Max power the battery can be charged at
  maxDischargeRateKw: 5.0, // Max power the battery can discharge at
  minSoc: 0.1,             // Minimum state of charge (10%)
};

const GRID_CONFIG = {
  maxImportCapacityKw: 14.0, // Household Maximum Import Capacity (MIC)
};

const CHARGE_WINDOW = {
  startHour: 2.0, // 2:00 AM
  endHour: 6.0,   // 6:00 AM
};

// --- Mock Baseline Data Generation ---
// Creates a plausible 24-hour energy consumption profile.
const generateBaselineData = () => {
  const data = [];
  for (let i = 0; i < 48; i++) {
    const hour = i * 0.5;
    let netKw;
    // Morning dip, daytime usage, evening peak, overnight low
    if (hour < 5) netKw = 0.5 + Math.random() * 0.5;
    else if (hour < 7) netKw = 1.5 + Math.random();
    else if (hour < 16) netKw = -0.5 + Math.random() * 1; // Some solar export
    else if (hour < 21) netKw = 2.5 + Math.random() * 1.5;
    else netKw = 0.8 + Math.random() * 0.5;
    
    // Make some periods higher to test battery discharge
    if(hour > 17 && hour < 19) netKw *= 1.5;

    data.push({
      time: `${String(Math.floor(hour)).padStart(2, '0')}:${i % 2 === 0 ? '00' : '30'}`,
      baseNetKw: parseFloat(netKw.toFixed(2)),
    });
  }
  return data;
};

// --- Main App Component ---
export default function App() {
  const [scenarioData, setScenarioData] = useState([]);
  const [darkMode, setDarkMode] = useState(true); // Defaulting to dark mode

  // This effect runs once to generate the baseline data and calculate the scenario
  useEffect(() => {
    const baselineData = generateBaselineData();
    const newScenarioData = calculateExportMaximiserScenario(baselineData);
    setScenarioData(newScenarioData);
  }, []);
  
  // The core logic for the "Export Maximiser" scenario
  const calculateExportMaximiserScenario = (baseline) => {
    let batterySoc = BATTERY_CONFIG.minSoc; // Start with minimum charge
    const calculatedData = [];

    // --- Pre-calculation Step ---
    // First, estimate how much energy is needed to cover all imports outside the cheap charging window.
    let energyNeededForSelfSufficiencyKwh = 0;
    baseline.forEach((d, i) => {
        const hour = i * 0.5;
        const isChargingWindow = hour >= CHARGE_WINDOW.startHour && hour < CHARGE_WINDOW.endHour;
        if (!isChargingWindow && d.baseNetKw > 0) {
            energyNeededForSelfSufficiencyKwh += d.baseNetKw * 0.5; // kW * 0.5 hours = kWh
        }
    });

    // Determine how much surplus energy we can plan to export after self-sufficiency
    const batteryEnergyWhenFullKwh = BATTERY_CONFIG.capacityKWh * (1 - BATTERY_CONFIG.minSoc);
    const surplusEnergyToExportKwh = Math.max(0, batteryEnergyWhenFullKwh - energyNeededForSelfSufficiencyKwh);
    
    // For simplicity, we'll force export this surplus in the last few hours before the next charge window
    const forceExportWindow = { start: 22, end: 24 };
    const forceExportDurationHours = forceExportWindow.end - forceExportWindow.start;
    const forceExportKw = forceExportDurationHours > 0 ? surplusEnergyToExportKwh / forceExportDurationHours : 0;
    const cappedForceExportKw = Math.min(forceExportKw, BATTERY_CONFIG.maxDischargeRateKw);

    // --- Main Simulation Loop (48 half-hour steps) ---
    for (let i = 0; i < 48; i++) {
        const hour = i * 0.5;
        const base = baseline[i];
        
        let newNetKw = base.baseNetKw;
        let batteryActionKw = 0;
        
        const isChargingWindow = hour >= CHARGE_WINDOW.startHour && hour < CHARGE_WINDOW.endHour;

        if (isChargingWindow) {
            // --- SCENARIO: Charge the battery ---
            const energyToFullKwh = (1 - batterySoc) * BATTERY_CONFIG.capacityKWh;
            const maxChargeKwh = BATTERY_CONFIG.maxChargeRateKw * 0.5;
            const maxFromGridKwh = Math.max(0, (GRID_CONFIG.maxImportCapacityKw - base.baseNetKw) * 0.5);
            
            const chargeKwh = Math.min(energyToFullKwh, maxChargeKwh, maxFromGridKwh);
            
            if (chargeKwh > 0) {
                batterySoc += chargeKwh / BATTERY_CONFIG.capacityKWh;
                batteryActionKw = -chargeKwh / 0.5; // Negative action = charging
                newNetKw += chargeKwh / 0.5; // Increase grid import
            }
        } else {
             // --- SCENARIO: Use the battery ---
             const isForceExportWindow = hour >= forceExportWindow.start && hour < forceExportWindow.end;
             let dischargeKwh = 0;

             // 1. Cover any grid import first
             if (newNetKw > 0) {
                const energyNeededKwh = newNetKw * 0.5;
                const availableFromBatteryKwh = (batterySoc - BATTERY_CONFIG.minSoc) * BATTERY_CONFIG.capacityKWh;
                const maxDischargeKwh = BATTERY_CONFIG.maxDischargeRateKw * 0.5;

                const dischargeToCoverImportKwh = Math.min(energyNeededKwh, availableFromBatteryKwh, maxDischargeKwh);
                if (dischargeToCoverImportKwh > 0) {
                    dischargeKwh += dischargeToCoverImportKwh;
                    newNetKw -= dischargeToCoverImportKwh / 0.5;
                }
             }

             // 2. Force export if in the designated window
             if (isForceExportWindow && cappedForceExportKw > 0) {
                const availableFromBatteryKwh = (batterySoc - BATTERY_CONFIG.minSoc) * BATTERY_CONFIG.capacityKWh - dischargeKwh;
                const maxDischargeKwh = BATTERY_CONFIG.maxDischargeRateKw * 0.5 - (dischargeKwh / 0.5);

                const forceDischargeKwh = Math.min(cappedForceExportKw * 0.5, availableFromBatteryKwh, maxDischargeKwh);
                 if (forceDischargeKwh > 0) {
                    dischargeKwh += forceDischargeKwh;
                    newNetKw -= forceDischargeKwh / 0.5; // Push grid value negative (export)
                }
             }
            
             if (dischargeKwh > 0) {
                batterySoc -= dischargeKwh / BATTERY_CONFIG.capacityKWh;
                batteryActionKw = dischargeKwh / 0.5; // Positive action = discharging
             }
        }
        
        calculatedData.push({
            ...base,
            newNetKw: parseFloat(newNetKw.toFixed(2)),
            batterySoc: parseFloat(batterySoc.toFixed(3)),
            batterySocPercent: parseFloat((batterySoc * 100).toFixed(1)),
        });
    }

    return calculatedData;
  };
  
  // This logic defines the gradient fill for the Area chart.
  // It calculates the point where the y-axis crosses zero to split the colors.
  const gradientOffset = useMemo(() => {
    if (!scenarioData || scenarioData.length === 0) return 0;

    const dataValues = scenarioData.map(i => i.newNetKw);
    const yMax = Math.max(...dataValues, 1);
    const yMin = Math.min(...dataValues, -1);

    if (yMax <= 0) return 0;
    if (yMin >= 0) return 1;

    return yMax / (yMax - yMin);
  }, [scenarioData]);

  // Dynamic colors for dark/light mode
  const colors = {
    bg: darkMode ? 'bg-gray-900' : 'bg-gray-100',
    text: darkMode ? 'text-gray-200' : 'text-gray-800',
    card: darkMode ? 'bg-gray-800' : 'bg-white',
    border: darkMode ? 'border-gray-700' : 'border-gray-200',
    axis: darkMode ? '#A0AEC0' : '#4A5568', // gray-400 vs gray-700
    grid: darkMode ? '#4A5568' : '#E2E8F0',  // gray-600 vs gray-200
  };

  return (
    <div className={`font-sans ${colors.bg} ${colors.text} min-h-screen p-4 sm:p-6 lg:p-8 transition-colors duration-300`}>
      <div className="max-w-7xl mx-auto">
        <header className="flex justify-between items-center mb-6">
            <h1 className="text-xl sm:text-2xl font-bold">Energy Optimisation Dashboard</h1>
            <button 
                onClick={() => setDarkMode(!darkMode)}
                className="px-4 py-2 rounded-lg bg-gray-700 text-white dark:bg-gray-200 dark:text-black transition-colors"
            >
                Toggle {darkMode ? 'Light' : 'Dark'} Mode
            </button>
        </header>
        
        <div className={`${colors.card} rounded-xl shadow-lg p-4 sm:p-6 border ${colors.border}`}>
          <h2 className="text-lg font-semibold mb-4 ml-8">Export Maximiser Scenario</h2>
          <div style={{ width: '100%', height: 450 }}>
            <ResponsiveContainer>
              <ComposedChart
                data={scenarioData}
                margin={{ top: 5, right: 20, left: -10, bottom: 5 }}
              >
                <defs>
                  <linearGradient id="splitColor" x1="0" y1="0" x2="0" y2="1">
                    <stop offset={gradientOffset} stopColor="#ef4444" stopOpacity={0.4}/> {/* red-500 for import */}
                    <stop offset={gradientOffset} stopColor="#22c55e" stopOpacity={0.4}/> {/* green-500 for export */}
                  </linearGradient>
                </defs>
                <CartesianGrid stroke={colors.grid} strokeDasharray="3 3" vertical={false} />
                <XAxis 
                  dataKey="time" 
                  tick={{ fill: colors.axis }}
                  tickLine={{ stroke: colors.axis }}
                  axisLine={{ stroke: colors.axis }}
                  interval={7} // Show a tick every ~4 hours
                />
                <YAxis 
                  yAxisId="left" 
                  label={{ value: 'Grid (kW)', angle: -90, position: 'insideLeft', fill: colors.axis }}
                  tick={{ fill: colors.axis }}
                  tickLine={{ stroke: colors.axis }}
                  axisLine={{ stroke: colors.axis }}
                  allowDecimals={false}
                />
                <YAxis 
                  yAxisId="right" 
                  orientation="right" 
                  domain={[0, 100]}
                  label={{ value: 'Battery SOC (%)', angle: 90, position: 'insideRight', fill: colors.axis }}
                  tick={{ fill: colors.axis }}
                  tickLine={{ stroke: colors.axis }}
                  axisLine={{ stroke: colors.axis }}
                />
                <Tooltip
                  contentStyle={{
                    backgroundColor: darkMode ? '#374151' : '#ffffff', // gray-700
                    borderColor: darkMode ? '#4B5563' : '#d1d5db' // gray-600
                  }}
                  labelStyle={{ color: colors.text }}
                  formatter={(value, name) => [
                      typeof value === 'number' ? value.toFixed(2) : value,
                      name
                  ]}
                />
                <Legend wrapperStyle={{ color: colors.text, paddingTop: '20px' }}/>
                <ReferenceLine y={0} yAxisId="left" stroke={colors.axis} strokeDasharray="2 2" />
                
                {/* Data Series */}
                <Line
                  yAxisId="left"
                  type="monotone"
                  dataKey="baseNetKw"
                  name="Baseline Net"
                  stroke={darkMode ? "#a78bfa" : "#8b5cf6"} // violet-400
                  strokeWidth={2}
                  strokeDasharray="5 5"
                  dot={false}
                />
                <Area
                  yAxisId="left"
                  type="monotone"
                  dataKey="newNetKw"
                  name="New Net (Import/Export)"
                  stroke={darkMode ? "#f87171" : "#dc2626"} // red-400
                  fill="url(#splitColor)"
                />
                <Line 
                  yAxisId="right"
                  type="monotone"
                  dataKey="batterySocPercent"
                  name="Battery SOC"
                  stroke={darkMode ? "#60a5fa" : "#3b82f6"} // blue-400
                  strokeWidth={2}
                  dot={false}
                />
              </ComposedChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>
    </div>
  );
}

